<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-dhEpx5xRpv">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.huatree.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。 它的第一个版本发布于 2012 年 10 月，经历了多次更新后，现在已成为前端社区中不可忽视的力量，不仅在 Microsoft 内部得到广泛运用，而且 Google 开发的 Angular 从 2.0 开始就使用了 TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript成长之路">
<meta property="og:url" content="https://www.huatree.top/2021/11/12/20211112-typescript%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/index.html">
<meta property="og:site_name" content="醉梦的网络日志">
<meta property="og:description" content="TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。 它的第一个版本发布于 2012 年 10 月，经历了多次更新后，现在已成为前端社区中不可忽视的力量，不仅在 Microsoft 内部得到广泛运用，而且 Google 开发的 Angular 从 2.0 开始就使用了 TypeScript">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.huatree.top/image-20230325140354690.png">
<meta property="article:published_time" content="2021-11-12T02:46:26.000Z">
<meta property="article:modified_time" content="2024-03-11T12:38:02.803Z">
<meta property="article:author" content="醉梦">
<meta property="article:tag" content="typescript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.huatree.top/image-20230325140354690.png">


<link rel="canonical" href="https://www.huatree.top/2021/11/12/20211112-typescript%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.huatree.top/2021/11/12/20211112-typescript%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/","path":"2021/11/12/20211112-typescript成长之路/","title":"typescript成长之路"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>typescript成长之路 | 醉梦的网络日志</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">醉梦的网络日志</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">最好的状态就是一点点向喜欢的东西靠近</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-简介"><a href="/about/" rel="section"><i class="fa fa-fw fa-vcard fa-fw"></i>简介</a></li><li class="menu-item menu-item-开源"><a href="/projects/" rel="section"><i class="fa fa-brands fa-codepen fa-fw"></i>开源</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-text">快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E5%8E%BB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B"><span class="nav-text">为什么推荐去官方文档查看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96"><span class="nav-text">常用依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsconfig-json%E9%85%8D%E7%BD%AE"><span class="nav-text">tsconfig.json配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8C%85%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="nav-text">打包辅助工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parcel"><span class="nav-text">parcel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack"><span class="nav-text">webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="nav-text">自定义打包辅助工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BF%86"><span class="nav-text">重点记忆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E5%8A%9F%E8%83%BD%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-text">有关功能的更多信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">类型操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="nav-text">从类型中创建类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">什么是类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text">使用泛型类型变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-text">泛型类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-text">泛型约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">在泛型约束中使用类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">在泛型中使用类类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8Bkeyof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">类型keyof运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">类型运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6"><span class="nav-text">限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">索引访问类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-text">条件类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-text">条件类型约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%96%AD"><span class="nav-text">在条件类型中进行推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-text">分布式条件类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">映射类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">映射修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E9%87%8D%E6%98%A0%E5%B0%84%E9%80%9A%E8%BF%87as"><span class="nav-text">键重映射通过as</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8E%A2%E7%B4%A2"><span class="nav-text">进一步探索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-text">模板文字类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%81%94%E5%90%88"><span class="nav-text">类型中的字符串联合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%81%94%E5%90%88-1"><span class="nav-text">类型中的字符串联合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%96%87%E5%AD%97%E6%8E%A8%E6%96%AD"><span class="nav-text">用模板文字推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-text">内部字符串操作类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">类成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getters-x2F-setters"><span class="nav-text">getters&#x2F;setters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89"><span class="nav-text">构造函数（构造器）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="nav-text">类继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#implements"><span class="nav-text">implements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extends"><span class="nav-text">extends</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="nav-text">重写方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-text">初始化顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">继承内置类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">成员可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#public"><span class="nav-text">public</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protected"><span class="nav-text">protected</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#private"><span class="nav-text">private</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E9%9D%99%E6%80%81%E5%90%8D%E7%A7%B0"><span class="nav-text">特殊静态名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9D%99%E6%80%81%E7%B1%BB"><span class="nav-text">为什么没有静态类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%87%8C%E7%9A%84-static%E5%8C%BA%E5%9D%97"><span class="nav-text">类里的 static区块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%AD%E7%9A%84this"><span class="nav-text">类运行时中的this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-%E5%8F%82%E6%95%B0"><span class="nav-text">this 参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E7%B1%BB%E5%9E%8B"><span class="nav-text">this类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E7%9A%84this"><span class="nav-text">基于类型守卫的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">参数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95"><span class="nav-text">类表达式写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="nav-text">抽象类和成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="nav-text">抽象构造签名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">类之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E6%A8%A1%E5%9D%97"><span class="nav-text">认识模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%AF%BC%E5%85%A5%E8%AF%AD%E6%B3%95"><span class="nav-text">额外的导入语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TS%E7%89%B9%E5%AE%9A%E7%9A%84ES%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="nav-text">TS特定的ES模块语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6"><span class="nav-text">声明合并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%8E%A5%E5%8F%A3"><span class="nav-text">合并接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">合并命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%9A%E4%B8%BE%E5%90%88%E5%B9%B6"><span class="nav-text">将命名空间与类、函数和枚举合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%B1%BB%E5%90%88%E5%B9%B6"><span class="nav-text">将命名空间与类合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E5%90%88%E5%B9%B6"><span class="nav-text">不允许合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%BB%84%E6%89%A9%E5%85%85"><span class="nav-text">模组扩充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%A2%9E%E5%BC%BA"><span class="nav-text">全局增强</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#issues"><span class="nav-text">issues</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%81%9A%E5%93%AA%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="nav-text">创建一个对象会做哪三件事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-text">js垃圾回收机制触发时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ts%E7%BC%96%E8%AF%91%E4%B8%BAes5%EF%BC%8Cclass%E7%BC%96%E8%AF%91%E6%88%90%E4%BA%86%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">ts编译为es5，class编译成了立即执行函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%AA%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="nav-text">静态方法中只能调用静态的方法或属性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%94%B9%E5%8F%98%E4%BA%86%E6%9F%90%E4%B8%AA%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%85%B6%E4%BB%96%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%88%96%E7%B1%BB%E5%A4%96%E9%83%A8%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E9%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="nav-text">一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%EF%BC%9F"><span class="nav-text">静态属性或方法分配内存空间的时间早于对象空间的分配？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="醉梦"
      src="/images/avatar-huatree.jpg">
  <p class="site-author-name" itemprop="name">醉梦</p>
  <div class="site-description" itemprop="description">黎明尚在，未来可戚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huatree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huatree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://codepen.io/" title="https:&#x2F;&#x2F;codepen.io&#x2F;" rel="noopener" target="_blank">codepen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://davidwalsh.name/" title="https:&#x2F;&#x2F;davidwalsh.name&#x2F;" rel="noopener" target="_blank">David Walsh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://simpleprogrammer.com/" title="https:&#x2F;&#x2F;simpleprogrammer.com&#x2F;" rel="noopener" target="_blank">Simple Programmer</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.smashingmagazine.com/2024/08/mastering-typography-in-logo-design/" title="https:&#x2F;&#x2F;www.smashingmagazine.com&#x2F;2024&#x2F;08&#x2F;mastering-typography-in-logo-design&#x2F;" rel="noopener" target="_blank">Smashing Magazine</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ruanyifeng.com/blog/" title="https:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰的网络日志</a>
        </li>
    </ul>
  </div>


  <div class="links-of-recent-posts site-overview-item animated">
    <div class="links-of-recent-posts-title">
      
      <i class="fa fa-history fa-fw"></i>
      
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
      
      
        <li class="links-of-recent-posts-item">
          <a href="/2022/12/03/20221203-uniapp%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="2022&#x2F;12&#x2F;03&#x2F;20221203-uniapp开发问题汇总&#x2F;">uniapp开发问题汇总</a>
        </li>
      
        <li class="links-of-recent-posts-item">
          <a href="/2023/05/25/20230525-%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" title="2023&#x2F;05&#x2F;25&#x2F;20230525-理解闭包与内存泄漏&#x2F;">理解闭包与内存泄漏</a>
        </li>
      
        <li class="links-of-recent-posts-item">
          <a href="/2024/03/31/20240331-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8BmacOS/" title="2024&#x2F;03&#x2F;31&#x2F;20240331-前端开发环境之macOS&#x2F;">前端开发环境之macOS</a>
        </li>
      
        <li class="links-of-recent-posts-item">
          <a href="/2024/03/09/20240309-%E9%A1%BE%E6%9D%91%E5%85%AC%E5%9B%AD%E7%9A%84%E6%97%A9%E6%A8%B1/" title="2024&#x2F;03&#x2F;09&#x2F;20240309-顾村公园的早樱&#x2F;">顾村公园的早樱</a>
        </li>
      
        <li class="links-of-recent-posts-item">
          <a href="/2024/02/05/20240205-ssh%E9%93%BE%E6%8E%A5github%E7%AB%AF%E5%8F%A322%E8%A2%AB%E6%8B%92%E7%BB%9D/" title="2024&#x2F;02&#x2F;05&#x2F;20240205-ssh链接github端口22被拒绝&#x2F;">ssh链接github端口22被拒绝</a>
        </li>
      
    </ul>
  </div>


        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.huatree.top/2021/11/12/20211112-typescript%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-huatree.jpg">
      <meta itemprop="name" content="醉梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉梦的网络日志">
      <meta itemprop="description" content="黎明尚在，未来可戚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="typescript成长之路 | 醉梦的网络日志">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          typescript成长之路
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-12 10:46:26" itemprop="dateCreated datePublished" datetime="2021-11-12T10:46:26+08:00">2021-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-11 20:38:02" itemprop="dateModified" datetime="2024-03-11T20:38:02+08:00">2024-03-11</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>45k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="http://www.typescriptlang.org/">TypeScript</a> 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>，它由 Microsoft 开发，代码<a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript">开源于 GitHub</a> 上。</p>
<p>它的第一个版本发布于 2012 年 10 月，经历了多次更新后，现在已成为前端社区中不可忽视的力量，不仅在 Microsoft 内部得到广泛运用，而且 Google 开发的 <a target="_blank" rel="noopener" href="https://angular.io/">Angular</a> 从 2.0 开始就使用了 TypeScript 作为开发语言，<a target="_blank" rel="noopener" href="https://vuejs.org/">Vue</a> 3.0 也使用 TypeScript 进行了重构。</p>
<p><img src="https://cdn.huatree.top/image-20230325140354690.png" alt="image-20230325140354690"></p>
<span id="more"></span>

<blockquote>
<p>学习方法：</p>
<p>先快速过，可标记疑难点，必须回顾所学，分析总结，转化成自己的理解与应用。</p>
</blockquote>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html">官方文档</a></p>
<h3 id="为什么推荐去官方文档查看"><a href="#为什么推荐去官方文档查看" class="headerlink" title="为什么推荐去官方文档查看"></a>为什么推荐去官方文档查看</h3><p>第三方文档可能不够细，甚至断章取义，原本一个容易理解的概念，第三方文档解释就变了味道。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出ts帮助，即指令用法</span></span><br><span class="line"><span class="comment"># 如果是在已存在的项目目录下执行该命令，则是编译项目</span></span><br><span class="line">$ tsc</span><br><span class="line"><span class="comment"># 查看当前安装的版本</span></span><br><span class="line">$ tsc -v</span><br><span class="line"><span class="comment"># 初始化项目</span></span><br><span class="line">$ tsc --init</span><br><span class="line"></span><br><span class="line">Created a new tsconfig.json with:                                                                                       </span><br><span class="line">                                                                                                                     TS </span><br><span class="line">  target: es2016</span><br><span class="line">  module: commonjs</span><br><span class="line">  strict: <span class="literal">true</span></span><br><span class="line">  esModuleInterop: <span class="literal">true</span></span><br><span class="line">  skipLibCheck: <span class="literal">true</span></span><br><span class="line">  forceConsistentCasingInFileNames: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can learn more at https://aka.ms/tsconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听文件改动</span></span><br><span class="line">$ tsc --watch</span><br></pre></td></tr></table></figure>

<h3 id="常用依赖"><a href="#常用依赖" class="headerlink" title="常用依赖"></a>常用依赖</h3><p>ts-node</p>
<p>简化 typescript 运行步骤，可直接在 node.js 环境中执行 ts 代码。</p>
<p>官网描述：用于 node.js 的 TypeScript 执行和 REPL，具有源映射和本机 ESM 支持。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node">详见</a></p>
<p>当然，如果适用vscode开发，可以使用Code Runner插件，选择需要运行的文件，鼠标右键选择Run Code即可执行编译输出。</p>
<p>nodemon</p>
<p>监控 node.js 应用程序中的任何更改并自动重启服务器 - 非常适合开发。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/remy/nodemon">详见</a></p>
<p>在package.json中配置如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nodemon --watch src/ -e ts --exec ts-node ./src/app.ts&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tsconfig-json配置"><a href="#tsconfig-json配置" class="headerlink" title="tsconfig.json配置"></a>tsconfig.json配置</h3><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig">详见官网</a></p>
<h2 id="打包辅助工具"><a href="#打包辅助工具" class="headerlink" title="打包辅助工具"></a>打包辅助工具</h2><h3 id="parcel"><a href="#parcel" class="headerlink" title="parcel"></a>parcel</h3><p><a target="_blank" rel="noopener" href="https://parceljs.org/docs/">详见</a></p>
<p>html中引入ts，可编译打包成js。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/">详见</a></p>
<h3 id="自定义打包辅助工具"><a href="#自定义打包辅助工具" class="headerlink" title="自定义打包辅助工具"></a>自定义打包辅助工具</h3><p><a target="_blank" rel="noopener" href="https://createapp.dev/">详见</a></p>
<h2 id="重点记忆"><a href="#重点记忆" class="headerlink" title="重点记忆"></a>重点记忆</h2><h2 id="有关功能的更多信息"><a href="#有关功能的更多信息" class="headerlink" title="有关功能的更多信息"></a>有关功能的更多信息</h2><p>函数重载</p>
<h2 id="类型操作"><a href="#类型操作" class="headerlink" title="类型操作"></a>类型操作</h2><h3 id="从类型中创建类型"><a href="#从类型中创建类型" class="headerlink" title="从类型中创建类型"></a>从类型中创建类型</h3><ul>
<li>泛型 - 带参数的类型</li>
<li>Keyof 类型操作符- keyof 操作符创建新类型</li>
<li>Typeof 类型操作符 - 使用 typeof 操作符来创建新的类型</li>
<li>索引访问类型 - 使用 Type[‘a’] 语法来访问一个类型的子集</li>
<li>条件类型 - 在类型系统中像if语句一样行事的类型</li>
<li>映射类型 - 通过映射现有类型中的每个属性来创建类型</li>
<li>模板字面量类型 - 通过模板字面字符串改变属性的映射类型</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是一种通用的编程概念，它允许在编写代码时不指定具体的类型，而是在使用代码时提供类型。通过使用泛型，可以编写更加通用和灵活的代码，使其能够适应不同的数据类型和数据结构。</p>
<p>在 TypeScript 中，泛型通常使用尖括号 <code>&lt; &gt;</code> 包裹，后跟一个标识符，例如 <code>T</code>、<code>U</code>、<code>K</code> 等等。这个标识符可以在代码中用作类型注释或泛型函数或类的参数。</p>
<p>例如，下面是一个泛型函数的例子，它使用类型参数 <code>T</code> 来表示一个数组中元素的类型，并返回数组中所有元素的和：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum&lt;T&gt;(<span class="attr">numbers</span>: T[]): T &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result += numbers[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>sum</code> 函数接受一个类型为 <code>T</code> 的数组，并返回类型为 <code>T</code> 的值。当我们使用 <code>sum</code> 函数时，需要提供一个实际的类型作为类型参数，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">sum</span>(numbers);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将 <code>numbers</code> 数组作为参数传递给 <code>sum</code> 函数，并在调用函数时使用 <code>number</code> 类型作为类型参数。函数将返回一个 <code>number</code> 类型的值，它是数组中所有元素的和。</p>
<p>通过使用泛型，我们可以编写可重用的代码，使其能够适应不同的数据类型和数据结构，从而提高代码的灵活性和通用性。</p>
<h4 id="什么是类型参数"><a href="#什么是类型参数" class="headerlink" title="什么是类型参数"></a>什么是类型参数</h4><p><strong>泛型也可以称为类型参数</strong>。在 TypeScript 中，泛型可以被用作类型参数，用于指定在编写代码时不确定的数据类型。</p>
<p>因此，泛型和类型参数的概念是相互关联的。泛型是一种通用的编程概念，用于指定在编写代码时不确定的数据类型，而<strong>类型参数则是指在使用泛型时需要提供的具体类型。</strong></p>
<h4 id="使用泛型类型变量"><a href="#使用泛型类型变量" class="headerlink" title="使用泛型类型变量"></a>使用泛型类型变量</h4><p>首先，让我们做一下泛型的 “ hello world”：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。</p>
<p>如果没有泛型，我们将不得不给身份函数一个特定的返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们可以用任意类型来描述身份函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 any 当然是通用的，因为它将使函数接受 arg 类型的<strong>任何和所有的类型</strong>。实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。</p>
<p>相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，<strong>对类型而不是数值起作用</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不借助编译器的类型推断写法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>相反，编译器只是查看了 “myString “这个值，并将Type设置为其类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = <span class="title function_">identity</span>(<span class="string">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们想在每次调用时将参数 arg 的长度记录到控制台，该怎么办？我们可能很想这样写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// error 类型“Type”上不存在属性“length”。</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们这样做时，编译器会给我们一个错误，说我们在使用 arg 的 .length 成员，但我们没有说arg 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个 number ，而这个数字没有一个 .length 成员。</p>
<p>比方说，我们实际上是想让这个函数在 Type 的数组上工作，而不是直接在 Type 上工作。既然我们在处理数组，那么 .length 成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以把 loggingIdentity 的类型理解为 “通用函数 loggingIdentity 接收一个类型参数 Type 和</p>
<p>一个参数 arg ， arg 是一个 Type 数组，并返回一个 Type 数组。” 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。<strong>这允许我们使用我们的通用类型变量 Type 作为我们正在处理的类型的一部分，而不是整个类型</strong>，给我们更大的灵活性。</p>
<p>我们也可以这样来写这个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt;): <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 数组有一个.length，所以不会再出错了</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array&lt;Type&gt;：整体是一个数组类型，Type是其中的一部分类型</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>在前面的部分中，我们创建了适用于一系列类型的通用身份函数。在本节中，我们将探讨函数本身的类型以及如何创建通用接口。</p>
<p>泛型函数的类型与非泛型函数的类型一样，首先列出类型参数，类似于函数声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Type</span>&gt;<span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="title class_">Type</span> = identity;</span><br></pre></td></tr></table></figure>

<p>我们也可以为类型中的泛型类型参数使用不同的名称，只要类型变量的数量和类型变量的使用方式一致即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Input</span>&gt;<span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Input</span> = identity;</span><br></pre></td></tr></table></figure>

<p>我们还可以将泛型类型写成<strong>对象字面量类型</strong>的调用签名：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &#123; &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#125; = identity;</span><br></pre></td></tr></table></figure>

<p>感觉有种匿名函数的写法，怪怪的。</p>
<p>这导致我们编写了第一个通用接口。让我们把前面例子中的<strong>对象字面量</strong>移到一个接口中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span> &#123;</span><br><span class="line">  &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span> = identity;</span><br></pre></td></tr></table></figure>

<p>在类似的示例中，我们可能希望<strong>将通用参数移动为整个接口的参数</strong>。这让我们可以看到我们通用的类型（例如，<code>Dictionary&lt;string&gt;</code>而不仅仅是<code>Dictionary</code>）。这使得类型参数对接口的所有其他成员可见。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>

<p>请注意，我们的示例已更改为略有不同。我们现在没有描述泛型函数，而是有一个非泛型函数签名，它是泛型类型的一部分。当我们使用<code>GenericIdentityFn</code>时，我们现在还需要指定相应的类型参数（此处：<code>number</code>），有效地锁定底层调用签名将使用的内容。了解何时将类型参数直接放在调用签名上以及何时将其放在接口本身上将有助于描述类型的哪些方面是通用的。</p>
<p>除了泛型接口，我们还可以创建泛型类。<strong>请注意，无法创建通用枚举和命名空间</strong>。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>类和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的</p>
<p>方式相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const b: Box&lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>类可以像接口一样使用通用约束和默认值。</p>
<p>静态成员中的类型参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 静态成员不能引用类的类型参数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">defaultValue</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Box&lt;string&gt;.defaultValue = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// console.log(Box&lt;number&gt;.defaultValue)</span></span><br></pre></td></tr></table></figure>

<p>请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box.defaultValue（如果有可能的话）也会改变Box.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。</p>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>在我们的<code>loggingIdentity</code>示例中，我们希望能够访问<code>.length</code>的属性<code>arg</code>，但编译器无法证明每个类型都有一个<code>.length</code>属性，因此它警告我们不能做出这种假设。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// error 类型“Type”上不存在属性“length”。</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不想使用任何和所有类型，而是希望将此函数限制为使用<em>也</em> 具有该<code>.length</code>属性的任何和所有类型。只要类型有这个成员，我们就允许它，但它至少需要有这个成员。为此，我们必须将我们的要求列为限制条件<code>Type</code>。</p>
<p>为此，我们将创建一个描述约束的接口。在这里，我们将创建一个具有单个<code>.length</code>属性的接口，然后我们将使用该接口和<code>extends</code>关键字来表示我们的约束：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); </span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型函数现在受到约束，所以它不再适用于所有类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(<span class="number">3</span>); <span class="comment">// error 类型“number”的参数不能赋给类型“Lengthwise”的参数。</span></span><br></pre></td></tr></table></figure>

<p>相反，我们需要传入其类型具有所有必需属性的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h4><p>您可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从给定名称的对象中获取属性。我们想确保我们不会意外获取<code>obj</code>上不存在的属性，因此我们将在两种类型之间放置一个约束：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;m&quot;</span>); <span class="comment">// error 类型“&quot;m&quot;”的参数不能赋给类型“&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;”的参数。 </span></span><br></pre></td></tr></table></figure>

<h4 id="在泛型中使用类类型"><a href="#在泛型中使用类类型" class="headerlink" title="在泛型中使用类类型"></a>在泛型中使用类类型</h4><p>在 TypeScript 中使用泛型创建工厂时，需要通过构造函数来引用类类型。例如，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> create&lt;<span class="title class_">Type</span>&gt;(<span class="attr">c</span>: &#123; <span class="keyword">new</span> (): <span class="title class_">Type</span> &#125;): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更高级的示例使用原型属性来推断和约束构造函数与类类型的实例端之间的关系。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeeKeeper</span> &#123;</span><br><span class="line">  <span class="attr">hasMask</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooKeeper</span> &#123;</span><br><span class="line">  <span class="attr">nametag</span>: <span class="built_in">string</span> = <span class="string">&quot;Mikle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">keeper</span>: <span class="title class_">BeeKeeper</span> = <span class="keyword">new</span> <span class="title class_">BeeKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">keeper</span>: <span class="title class_">ZooKeeper</span> = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> createInstance&lt;A <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt;(<span class="attr">c</span>: <span class="keyword">new</span> () =&gt; A): A &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Lion</span>).<span class="property">keeper</span>.<span class="property">nametag</span>;</span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Bee</span>).<span class="property">keeper</span>.<span class="property">hasMask</span>;</span><br></pre></td></tr></table></figure>

<p>此模式用于为<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/mixins.html">混合</a>设计模式提供动力。</p>
<h3 id="类型keyof运算符"><a href="#类型keyof运算符" class="headerlink" title="类型keyof运算符"></a>类型<code>keyof</code>运算符</h3><p>运算<code>keyof</code>符采用对象类型并生成其键的字符串或数字文字联合。以下类型 P 与“x” | ”y“是同一类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// P: type p = keyof Point</span></span><br><span class="line"><span class="keyword">type</span> P = keyof <span class="title class_">Point</span>;</span><br></pre></td></tr></table></figure>

<p>如果类型有一个<code>string</code>或<code>number</code>索引签名，<code>keyof</code>将返回这些类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arrayish</span> = &#123; [<span class="attr">n</span>: <span class="built_in">number</span>]: <span class="built_in">unknown</span> &#125;;</span><br><span class="line"><span class="comment">// type A = number</span></span><br><span class="line"><span class="keyword">type</span> A = keyof <span class="title class_">Arrayish</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mapish</span> = &#123; [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="comment">// type M = string | number</span></span><br><span class="line"><span class="keyword">type</span> M = keyof <span class="title class_">Mapish</span>;</span><br></pre></td></tr></table></figure>

<p>请注意，在此示例中，<code>M</code>是 <code>string | number</code>， 这是因为 JavaScript 对象键始终被强制转换为字符串，因此<code>obj[0]</code>始终转为<code>obj[&quot;0&quot;]</code>.</p>
<p><code>keyof</code>类型在与映射类型结合使用时变得特别有用，我们稍后将详细了解这一点。</p>
<h3 id="类型运算符"><a href="#类型运算符" class="headerlink" title="类型运算符"></a>类型运算符</h3><p>JavaScript 已经有一个<code>typeof</code>可以在<em>表达式</em>上下文中使用的运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>TypeScript 添加了一个<code>typeof</code>运算符，您可以在<em>类型</em>上下文中使用它来引用变量或属性的<em>类型：</em></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="keyword">typeof</span> s; <span class="comment">// let n: string</span></span><br></pre></td></tr></table></figure>

<p>这对基本类型不是很有用，但结合其他类型运算符，可以<code>typeof</code>方便地表达许多模式。例如，让我们从查看预定义类型开始<code>ReturnType&lt;T&gt;</code>，它接受一个<em>函数类型</em>并产生它的返回类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Predicate</span> = <span class="function">(<span class="params">x: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> K = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Predicate</span>&gt;; <span class="comment">// type K = boolean</span></span><br></pre></td></tr></table></figure>

<p><code>ReturnType</code>如果我们尝试在函数名称上使用，我们会看到一个指示性错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;f&gt;; <span class="comment">// error “f”表示值，但在此处用作类型。是否指“类型 f”?</span></span><br></pre></td></tr></table></figure>

<p>请记住，<em>值</em>和<em>类型</em>不是一回事。要引用值的<em>类型</em>，我们使用：<code>f typeof</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f&gt;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">type</span> P = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>TypeScript 有意限制了你可以使用的表达式种类<code>typeof</code>。</p>
<p><code>typeof</code>具体来说，<strong>只有在标识符（即变量名）或其属性上使用才是合法的</strong>。这有助于避免编写您认为正在执行但实际上不是的代码的混乱陷阱：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">msgbox</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// Meant to use = ReturnType&lt;typeof msgbox&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">shouldContinue</span>: <span class="keyword">typeof</span> <span class="title function_">msgbox</span>(<span class="string">&quot;Are you sure you want to continue?&quot;</span>); <span class="comment">// error 应为“,”。</span></span><br></pre></td></tr></table></figure>

<h3 id="索引访问类型"><a href="#索引访问类型" class="headerlink" title="索引访问类型"></a>索引访问类型</h3><p>我们可以使用<em>索引访问类型</em>来查找另一种类型的特定属性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">alive</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>]; <span class="comment">// type Age = number</span></span><br></pre></td></tr></table></figure>

<p>索引类型本身就是一种类型，因此我们可以<code>keyof</code>完全使用联合、 或其他类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>]; <span class="comment">// type I1 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>]; <span class="comment">// type I2 = string | number | boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AliveOrName</span> = <span class="string">&quot;alive&quot;</span> | <span class="string">&quot;name&quot;</span>; </span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I3</span> = <span class="title class_">Person</span>[<span class="title class_">AliveOrName</span>]; <span class="comment">// type I3 = string | boolean</span></span><br></pre></td></tr></table></figure>

<p>如果您尝试索引一个不存在的属性，您甚至会看到一个错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;alve&quot;</span>]; <span class="comment">// error 类型“Person”上不存在属性“alve”。</span></span><br></pre></td></tr></table></figure>

<p>使用任意类型进行索引的另一个示例是使用<code>number</code>获取数组元素的类型。我们可以将它与<code>typeof</code> 结合起来以方便地捕获数组文字的元素类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>]; <span class="comment">// type Person = &#123;name: string;age: number;&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>][<span class="string">&quot;age&quot;</span>]; <span class="comment">// type Age = number</span></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age2</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>]; <span class="comment">// type Age2 = number</span></span><br></pre></td></tr></table></figure>

<p>您只能在索引时使用类型，这意味着您不能使用 <code>const</code>来进行变量引用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * error </span></span><br><span class="line"><span class="comment"> * 类型“key”不能作为索引类型使用。</span></span><br><span class="line"><span class="comment"> * “key”表示值，但在此处用作类型。是否指“类型 key”?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key]; </span><br></pre></td></tr></table></figure>

<p>但是，您可以为类似风格的重构使用类型别名：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br></pre></td></tr></table></figure>

<h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>在最有用的程序的核心，我们必须根据输入做出决定。JavaScript 程序没有什么不同，但考虑到值可以很容易地自省这一事实，这些决定也基于输入的类型。 <em>条件类型</em>有助于描述输入和输出类型之间的关系。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>; <span class="comment">// type Example1 = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>; <span class="comment">// type Example2 = string</span></span><br></pre></td></tr></table></figure>

<p>条件类型的形式有点像JavaScript 中的条件表达式 (<code>condition ? trueExpression : falseExpression</code>)：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SomeType</span> <span class="keyword">extends</span> <span class="title class_">OtherType</span> ? <span class="title class_">TrueType</span> : <span class="title class_">FalseType</span>;</span><br></pre></td></tr></table></figure>

<p>当左侧的类型<code>extends</code>可分配给右侧的类型时，您将获得第一个分支（“真实”分支）中的类型；否则你会在后一个分支（“false”分支）中得到类型。</p>
<p>从上面的示例中，条件类型可能不会立即看起来有用 - 我们可以告诉自己是否<code>Dog extends Animal</code>选择<code>number</code>or <code>string</code>！但条件类型的强大之处在于将它们与泛型一起使用。</p>
<p>例如，让我们采用以下<code>createLabel</code>功能：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdLabel</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">/* some fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">/* other fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">id: <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createLabel 的这些重载描述了一个 JavaScript 函数，该函数根据其输入的类型做出选择。注意几点：</p>
<ol>
<li>如果一个库必须在其 API 中一遍又一遍地做出相同类型的选择，这将变得很麻烦。</li>
<li>我们必须创建三个重载：一个用于我们<em>确定</em>类型的每种情况（一个用于<code>string</code>，一个用于<code>number</code>），一个用于最一般的情况（采用 a <code>string | number</code>）。对于每个可以处理的新类型<code>createLabel</code>，重载的数量呈指数增长。</li>
</ol>
<p>相反，我们可以将该逻辑编码为条件类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrId</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">  ? <span class="title class_">IdLabel</span></span><br><span class="line">  : <span class="title class_">NameLabel</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用该条件类型将我们的重载简化为没有重载的单个函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createLabel&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt;(<span class="attr">idOrName</span>: T): <span class="title class_">NameOrId</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">createLabel</span>(<span class="string">&quot;typescript&quot;</span>); <span class="comment">// let a: NameLabel</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">createLabel</span>(<span class="number">2.8</span>); <span class="comment">// let b: IdLabel</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">createLabel</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() ? <span class="string">&quot;hello&quot;</span> : <span class="number">42</span>); <span class="comment">// let c: NameLabel | IdLabel</span></span><br></pre></td></tr></table></figure>

<h4 id="条件类型约束"><a href="#条件类型约束" class="headerlink" title="条件类型约束"></a>条件类型约束</h4><p>通常，条件类型的检查会为我们提供一些新信息。就像使用类型保护进行缩小可以为我们提供更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步限制泛型。</p>
<p>例如，让我们采取以下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T[<span class="string">&quot;message&quot;</span>]; <span class="comment">// error 类型“&quot;message&quot;”无法用于索引类型“T”。</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，TypeScript 出错是因为<code>T</code>不知道有一个名为 的属性<code>message</code>。我们可以约束<code>T</code>，TypeScript 将不再抱怨：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125;&gt; = T[<span class="string">&quot;message&quot;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;; <span class="comment">// type EmailMessageContents = string</span></span><br></pre></td></tr></table></figure>

<p>但是，如果我们想<code>MessageOf</code>采用任何类型，并默认为某个属性不可用<code>never</code>时怎么办？<code>message</code>我们可以通过移出约束并引入条件类型来做到这一点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125; ? T[<span class="string">&quot;message&quot;</span>] : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;; <span class="comment">// type EmailMessageContents = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;; <span class="comment">// type DogMessageContents = never</span></span><br></pre></td></tr></table></figure>

<p>在 true 分支中，TypeScript 知道<code>T</code> <em>将</em>有一个<code>message</code>属性。</p>
<p>作为另一个示例，我们还可以编写一个名为<code>Flatten</code>的类型，将数组类型展平为它们的元素类型，但除此之外别管它们：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Extracts out the element type.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;; <span class="comment">// type Str = string</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Leaves the type alone.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;; <span class="comment">// type Num = number</span></span><br></pre></td></tr></table></figure>

<p>当<code>Flatten</code>给定一个数组类型时，它使用索引<code>number</code>访问来获取 的<code>string[]</code>元素类型。否则，它只返回给定的类型。</p>
<h4 id="在条件类型中进行推断"><a href="#在条件类型中进行推断" class="headerlink" title="在条件类型中进行推断"></a>在条件类型中进行推断</h4><p>我们只是发现自己使用条件类型来应用约束，然后提取类型。这最终成为一种常见的操作，条件类型使它变得更容易。</p>
<p>条件类型为我们提供了一种方法，可以使用<code>infer</code>关键字从我们在真实分支中比较的类型进行推断。例如，我们可以推断元素类型<code>Flatten</code>而不是使用索引访问类型“手动”取出它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用<code>infer</code>关键字声明性地引入一个新的泛型类型变量 named而不是指定如何在 true 分支中<code>Item</code>检索元素类型。<code>T</code>这使我们不必考虑如何深入挖掘和剖析我们感兴趣的类型的结构。</p>
<p>我们可以使用关键字编写一些有用的辅助类型别名<code>infer</code>。例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetReturnType</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">never</span>[]) =&gt; infer <span class="title class_">Return</span></span><br><span class="line">  ? <span class="title class_">Return</span></span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;; <span class="comment">// type Num = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// type Str = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bools</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">boolean</span>, b: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>[]&gt;; <span class="comment">// type Bools = boolean[]</span></span><br></pre></td></tr></table></figure>

<p>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将根据<em>最后一个</em>签名进行推断（这大概是最宽松的包罗万象的情况）。不可能根据参数类型列表执行重载决策。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> stringOrNum&gt;; <span class="comment">// type T1 = string | number</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&#x27;hello&#x27;</span> : <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> stringOrNum&gt;; <span class="comment">// type T1 = string | number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">t1</span>: <span class="variable constant_">T1</span> = <span class="literal">true</span> <span class="comment">// error 不能将类型“boolean”分配给类型“string”。</span></span><br></pre></td></tr></table></figure>

<p><code>Math.random()</code>是随机的，<code>const t1: T1 = true</code>可有可能<code>error 不能将类型“boolean”分配给类型“number”</code>。</p>
<h4 id="分布式条件类型"><a href="#分布式条件类型" class="headerlink" title="分布式条件类型"></a>分布式条件类型</h4><p>当条件类型作用于泛型类型时，它们在给定联合类型时变得<em>具有分配性。</em>例如，采用以下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们将联合类型插入到 中<code>ToArray</code>，则条件类型将应用于该联合的每个成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// type StrArrOrNumArr = string[] | number[]</span></span><br></pre></td></tr></table></figure>

<p>这里发生的是<code>StrArrOrNumArr</code>分布在：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>并将联合的每个成员类型映射到有效的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>&gt; | <span class="title class_">ToArray</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这给我们留下了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] | <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure>

<p>通常，分配性是所需的行为。<code>extends</code>为避免这种行为，您可以用方括号将关键字的每一侧括起来。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArrayNonDist</span>&lt;<span class="title class_">Type</span>&gt; = [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &#x27;StrArrOrNumArr&#x27; is no longer a union.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArrayNonDist</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// type StrArrOrNumArr = (string | number)[]</span></span><br></pre></td></tr></table></figure>

<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>当您不想重复自己时，有时一种类型需要基于另一种类型。</p>
<p>映射类型建立在索引签名的语法之上，用于声明未提前声明的属性类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | <span class="title class_">Horse</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">conforms</span>: <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">  <span class="attr">del</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">rodney</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>映射类型是一种通用类型，它使用<code>PropertyKeys</code>的联合（通常通过 <code>keyof</code>创建）来遍历键以创建类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>OptionsFlags</code>将从类型中获取所有属性<code>Type</code>并将它们的值更改为布尔值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureFlags</span> = &#123;</span><br><span class="line">    <span class="attr">darkMode</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">newUserProfile</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">type FeatureOptions = &#123;</span></span><br><span class="line"><span class="comment">    darkMode: boolean;</span></span><br><span class="line"><span class="comment">    newUserProfile: boolean;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureOptions</span> = <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">FeatureFlags</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h4><p>在映射期间可以应用两个额外的修饰符：<code>readonly</code>和<code>?</code>分别影响可变性和可选性。</p>
<p>您可以通过前缀<code>-</code>或<code>+</code>来删除或添加这些修饰符。如果您不添加前缀，则假定为<code>+</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removes &#x27;readonly&#x27; attributes from a type&#x27;s properties</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    -<span class="keyword">readonly</span> [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LockedAccount</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  type UnlockedAccount = &#123;</span></span><br><span class="line"><span class="comment">      id: string;</span></span><br><span class="line"><span class="comment">      name: string;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnlockedAccount</span> = <span class="title class_">CreateMutable</span>&lt;<span class="title class_">LockedAccount</span>&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removes &#x27;optional&#x27; attributes from a type&#x27;s properties</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeUser</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type User = &#123;</span></span><br><span class="line"><span class="comment">    id: string;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MaybeUser</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="键重映射通过as"><a href="#键重映射通过as" class="headerlink" title="键重映射通过as"></a>键重映射通过<code>as</code></h4><p>在 TypeScript 4.1 及更高版本中，您可以使用映射类型中的子句<code>as</code>重新映射映射类型中的键：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MappedTypeWithNewProperties</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    [<span class="title class_">Properties</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">NewKeyType</span>]: <span class="title class_">Type</span>[<span class="title class_">Properties</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以利用模板字面量类型等功能从先前的属性名称创建新的属性名称：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type LazyPerson = &#123;</span></span><br><span class="line"><span class="comment">    getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">    getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">    getLocation: () =&gt; string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>您可以通过条件类型生成<code>never</code>来过滤掉键：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove the &#x27;kind&#x27; property</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;<span class="title class_">Property</span>, <span class="string">&quot;kind&quot;</span>&gt;]: <span class="title class_">Type</span>[<span class="title class_">Property</span>]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type KindlessCircle = &#123;</span></span><br><span class="line"><span class="comment">    radius: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KindlessCircle</span> = <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Circle</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>您可以映射任意联合，不仅<code>string | number | symbol</code> 的联合，还可以是任何类型的联合：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventConfig</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SquareEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>, <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CircleEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>, <span class="attr">radius</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Config = &#123;</span></span><br><span class="line"><span class="comment">    square: (event: SquareEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">    circle: (event: CircleEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">EventConfig</span>&lt;<span class="title class_">SquareEvent</span> | <span class="title class_">CircleEvent</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h4><p>映射类型与此类型操作部分中的其他功能配合得很好，例如，这里是一个使用条件类型的映射类型，它返回 <code>true</code>或<code>false</code>取决于对象是否将属性<code>pii</code>设置为字面意义上的<code>true</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractPII</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>] <span class="keyword">extends</span> &#123; <span class="attr">pii</span>: <span class="literal">true</span> &#125; ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DBFields</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: &#123; <span class="attr">format</span>: <span class="string">&quot;incrementing&quot;</span> &#125;;</span><br><span class="line">  <span class="attr">name</span>: &#123; <span class="attr">type</span>: <span class="built_in">string</span>; <span class="attr">pii</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type ObjectsNeedingGDPRDeletion = &#123;</span></span><br><span class="line"><span class="comment">    id: false;</span></span><br><span class="line"><span class="comment">    name: true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectsNeedingGDPRDeletion</span> = <span class="title class_">ExtractPII</span>&lt;<span class="title class_">DBFields</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="模板文字类型"><a href="#模板文字类型" class="headerlink" title="模板文字类型"></a>模板文字类型</h3><p>模板字面量类型建立在字符串字面量类型之上，并且能够通过联合扩展为多个字符串。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">它们与 JavaScript 中的模板文字字符串</a>具有相同的语法，但用于类型位置。当与具体文字类型一起使用时，模板文字通过连接内容生成新的字符串文字类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>; <span class="comment">// type Greeting = &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>当在插值位置使用联合时，类型是每个联合成员可以表示的每个可能字符串文字的集合：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EmailLocaleIDs</span> = <span class="string">&quot;welcome_email&quot;</span> | <span class="string">&quot;email_heading&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooterLocaleIDs</span> = <span class="string">&quot;footer_title&quot;</span> | <span class="string">&quot;footer_sendoff&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>; <span class="comment">// type AllLocaleIDs = &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于模板字面量中的每个插值位置，并集交叉相乘：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;en&quot;</span> | <span class="string">&quot;ja&quot;</span> | <span class="string">&quot;pt&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LocaleMessageIDs</span> = <span class="string">`<span class="subst">$&#123;Lang&#125;</span>_<span class="subst">$&#123;AllLocaleIDs&#125;</span>`</span>; <span class="comment">// type LocaleMessageIDs = &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们通常建议人们对大型字符串联合使用提前生成，但这在较小的情况下很有用。</p>
<h4 id="类型中的字符串联合"><a href="#类型中的字符串联合" class="headerlink" title="类型中的字符串联合"></a>类型中的字符串联合</h4><p>模板字面量类型建立在<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">字符串字面量类型</a>之上，并且能够通过联合扩展为多个字符串。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">它们与 JavaScript 中的模板文字字符串</a>具有相同的语法，但用于类型位置。当与具体文字类型一起使用时，模板文字通过连接内容生成新的字符串文字类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>; <span class="comment">// type Greeting = &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>当在插值位置使用联合时，类型是每个联合成员可以表示的每个可能字符串文字的集合：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EmailLocaleIDs</span> = <span class="string">&quot;welcome_email&quot;</span> | <span class="string">&quot;email_heading&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooterLocaleIDs</span> = <span class="string">&quot;footer_title&quot;</span> | <span class="string">&quot;footer_sendoff&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type AllLocaleIDs = &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<p>对于模板字面量中的每个插值位置，<strong>并集交叉相乘</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AllLocaleIDs</span> = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> = <span class="string">&quot;en&quot;</span> | <span class="string">&quot;ja&quot;</span> | <span class="string">&quot;pt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type LocaleMessageIDs = &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LocaleMessageIDs</span> = <span class="string">`<span class="subst">$&#123;Lang&#125;</span>_<span class="subst">$&#123;AllLocaleIDs&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>我们通常建议人们对大型字符串联合使用提前生成，但这在较小的情况下很有用。</p>
<h4 id="类型中的字符串联合-1"><a href="#类型中的字符串联合-1" class="headerlink" title="类型中的字符串联合"></a>类型中的字符串联合</h4><p>当基于类型中的信息定义新字符串时，模板字面量的威力就体现出来了。</p>
<p>考虑这样一种情况，函数 ( <code>makeWatchedObject</code>) 添加一个新函数<code>on()</code>调用给传递的对象。在 JavaScript 中，它的调用可能如下所示 <code>makeWatchedObject(baseObject)</code>：我们可以想象基础对象看起来像：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> passedObject = &#123;</span><br><span class="line">  firstName = <span class="string">&quot;Saoirse&quot;</span>,</span><br><span class="line">  lastName = <span class="string">&quot;Ronan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>on</code>将添加到基础对象的函数需要两个参数，一个 <code>eventName</code>(a <code>string</code>) 和一个<code>callBack</code>(a <code>function</code>)。</p>
<p>这个<code>eventName</code>应该是<code>attributeInThePassedObject + &quot;Changed&quot;</code>; 因此，<code>firstNameChanged</code>从基础对象中的<code>firstName</code>属性派生。</p>
<p>该<code>callBack</code>函数在调用时：</p>
<ul>
<li>应传递与名称关联的类型的值<code>attributeInThePassedObject</code>；因此，由于<code>firstName</code>类型为<code>string</code>，事件的回调<code>firstNameChanged</code>期望在调用时将 a<code>string</code>传递给它。类似地，与关联的事件<code>age</code>应该期望用<code>number</code>参数调用</li>
<li>应该有<code>void</code>返回类型（为了演示的简单性）</li>
</ul>
<p>因此， 的原始函数签名<code>on()</code>可能是：<code>on(eventName: string, callBack: (newValue: any) =&gt; void)</code>。但是，在前面的描述中，我们确定了我们希望在代码中记录的重要类型约束。模板文字类型让我们将这些约束带入我们的代码中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">makeWatchedObject</span>(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Saoirse&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Ronan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// makeWatchedObject has added `on` to the anonymous Object</span></span><br><span class="line"> </span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;firstNameChanged&quot;</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`firstName was changed to <span class="subst">$&#123;newValue&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>请注意，<code>on</code>监听事件<code>&quot;firstNameChanged&quot;</code>，而不仅仅是<code>&quot;firstName&quot;</code>. <code>on()</code>如果我们要确保符合条件的事件名称集受监视对象中属性名称的联合约束，并在末尾添加“已更改”，我们的天真规范可能会变得更加健壮。虽然我们很乐意在 JavaScript ie 中进行这样的计算<code>Object.keys(passedObject).map(x =&gt;</code>${x}Changed<code>)</code>，但<em>类型系统中的</em>模板文字提供了类似的字符串操作方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">on</span>(<span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span> &amp; keyof Type&#125;</span>Changed`</span>, <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// Create a &quot;watched object&quot; with an &#x27;on&#x27; method</span></span><br><span class="line"><span class="comment">/// so that you can watch for changes to properties.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> makeWatchedObject&lt;<span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &amp; <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>有了这个，我们可以构建一些在给定错误属性时出错的东西：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">makeWatchedObject</span>(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Saoirse&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Ronan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;firstNameChanged&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// Prevent easy human error (using the key instead of the event name)</span></span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;firstName&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// error Argument of type &#x27;&quot;firstName&quot;&#x27; is not assignable to parameter of type &#x27;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s typo-resistant</span></span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;frstNameChanged&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// error Argument of type &#x27;&quot;frstNameChanged&quot;&#x27; is not assignable to parameter of type &#x27;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#x27;.</span></span><br></pre></td></tr></table></figure>

<h4 id="用模板文字推断"><a href="#用模板文字推断" class="headerlink" title="用模板文字推断"></a>用模板文字推断</h4><p>请注意，我们并未受益于原始传递对象中提供的所有信息。给定 a 的变化<code>firstName</code>（即<code>firstNameChanged</code>事件），我们应该期望回调将接收 type <code>string</code>的参数。同样，更改为的回调<code>age</code>应该接收一个<code>number</code>参数。我们天真地使用<code>any</code>to type the<code>callBack</code>的参数。同样，模板文字类型可以确保属性的数据类型与该属性的回调的第一个参数的类型相同。</p>
<p>使这成为可能的关键见解是：我们可以使用具有泛型的函数，这样：</p>
<ol>
<li>第一个参数中使用的文字被捕获为文字类型</li>
<li>该文字类型可以被验证为在泛型中的有效属性的联合中</li>
<li>可以使用索引访问在泛型的结构中查找经过验证的属性的类型</li>
<li><em>然后</em>可以应用此类型信息以确保回调函数的参数属于同一类型</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    on&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> <span class="built_in">string</span> &amp; keyof <span class="title class_">Type</span>&gt;</span><br><span class="line">        (<span class="attr">eventName</span>: <span class="string">`<span class="subst">$&#123;Key&#125;</span>Changed`</span>, <span class="attr">callback</span>: <span class="function">(<span class="params">newValue: Type[Key]</span>) =&gt;</span> <span class="built_in">void</span> ): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> makeWatchedObject&lt;<span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &amp; <span class="title class_">PropEventSource</span>&lt;<span class="title class_">Type</span>&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">makeWatchedObject</span>(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Saoirse&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Ronan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;firstNameChanged&quot;</span>, <span class="function"><span class="params">newName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// (parameter) newName: string</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`new name is <span class="subst">$&#123;newName.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">on</span>(<span class="string">&quot;ageChanged&quot;</span>, <span class="function"><span class="params">newAge</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// (parameter) newAge: number</span></span><br><span class="line">  <span class="keyword">if</span> (newAge &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;warning! negative age&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们制作成<code>on</code>泛型方法。</p>
<p>当用户使用字符串调用时<code>&quot;firstNameChanged&quot;</code>，TypeScript 将尝试为 推断正确的类型<code>Key</code>。为此，它将匹配<code>Key</code>之前的内容<code>&quot;Changed&quot;</code>并推断字符串<code>&quot;firstName&quot;</code>。一旦 TypeScript 弄清楚了这一点，该方法就可以获取原始对象的<code>on</code>类型，在本例中就是这样。同样，当使用调用时，TypeScript 会找到属性的类型。<code>firstName``string``&quot;ageChanged&quot;``age``number</code></p>
<p>推理可以以不同的方式组合，通常是解构字符串，并以不同的方式重建它们。</p>
<h4 id="内部字符串操作类型"><a href="#内部字符串操作类型" class="headerlink" title="内部字符串操作类型"></a>内部字符串操作类型</h4><p>为了帮助进行字符串操作，TypeScript 包含一组可用于字符串操作的类型。这些类型内置于编译器中以提高性能，并且无法在TypeScript 附带的文件<code>.d.ts</code>中找到。</p>
<p><strong>Uppercase<StringType></strong></p>
<p>将字符串中的每个字符转换为大写版本。</p>
<p>例子</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ShoutyGreeting</span> = <span class="title class_">Uppercase</span>&lt;<span class="title class_">Greeting</span>&gt; <span class="comment">// type ShoutyGreeting = &quot;HELLO, WORLD&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ASCIICacheKey</span>&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`ID-<span class="subst">$&#123;Uppercase&lt;Str&gt;&#125;</span>`</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MainID</span> = <span class="title class_">ASCIICacheKey</span>&lt;<span class="string">&quot;my_app&quot;</span>&gt; <span class="comment">// type MainID = &quot;ID-MY_APP&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Lowercase<StringType></strong></p>
<p>将字符串中的每个字符转换为等效的小写字母。</p>
<p>例子</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">QuietGreeting</span> = <span class="title class_">Lowercase</span>&lt;<span class="title class_">Greeting</span>&gt; <span class="comment">// type QuietGreeting = &quot;hello, world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ASCIICacheKey</span>&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`id-<span class="subst">$&#123;Lowercase&lt;Str&gt;&#125;</span>`</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MainID</span> = <span class="title class_">ASCIICacheKey</span>&lt;<span class="string">&quot;MY_APP&quot;</span>&gt; <span class="comment">// type MainID = &quot;id-my_app&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Capitalize<StringType></strong></p>
<p>将字符串中的第一个字符转换为等效的大写字母。</p>
<p>例子</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LowercaseGreeting</span> = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="title class_">Capitalize</span>&lt;<span class="title class_">LowercaseGreeting</span>&gt;; <span class="comment">// type Greeting = &quot;Hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Uncapitalize<StringType></strong></p>
<p>将字符串中的第一个字符转换为等效的小写字母。</p>
<p>例子</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UppercaseGreeting</span> = <span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UncomfortableGreeting</span> = <span class="title class_">Uncapitalize</span>&lt;<span class="title class_">UppercaseGreeting</span>&gt;; <span class="comment">// type UncomfortableGreeting = &quot;hELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内在字符串操作类型的技术细节</p>
</blockquote>
<p>从 TypeScript 4.1 开始，这些内部函数的代码直接使用 JavaScript 字符串运行时函数进行操作，并且无需了解区域设置。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyStringMapping</span>(<span class="params"><span class="built_in">symbol</span>: <span class="built_in">Symbol</span>, str: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (intrinsicTypeKinds.<span class="title function_">get</span>(<span class="built_in">symbol</span>.<span class="property">escapedName</span> <span class="keyword">as</span> <span class="built_in">string</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Uppercase</span>: <span class="keyword">return</span> str.<span class="title function_">toUpperCase</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Lowercase</span>: <span class="keyword">return</span> str.<span class="title function_">toLowerCase</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Capitalize</span>: <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Uncapitalize</span>: <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toLowerCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>属性、方法、readonly、、getters&#x2F;setters、索引签名</p>
<h4 id="getters-x2F-setters"><a href="#getters-x2F-setters" class="headerlink" title="getters&#x2F;setters"></a>getters&#x2F;setters</h4><blockquote>
<p>请注意，一个没有额外逻辑的字段支持的 get&#x2F;set 对在JavaScript中很少有用。如果你不需要在get&#x2F;set 操作中添加额外的逻辑，暴露公共字段也是可以的。</p>
</blockquote>
<p>TypeScript对访问器有一些特殊的推理规则：</p>
<ul>
<li>如果存在 get ，但没有 set ，则该属性自动是只读的</li>
<li>如果没有指定 setter 参数的类型，它将从 getter 的返回类型中推断出来</li>
<li>访问器和设置器必须有相同的成员可见性</li>
</ul>
<p>从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">  _size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">size</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="title class_">Number</span>(value);</span><br><span class="line">    <span class="comment">// 不允许NaN、Infinity等</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(num)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问器和设置器必须有相同的成员可见性？</p>
<p>在 TypeScript 中，访问器和设置器必须有相同的成员可见性。也就是说，如果您为一个成员定义了访问器或设置器，那么这个成员的访问级别必须与访问器或设置器中的访问级别相同。</p>
<p>例如，如果您为一个类的私有成员定义了访问器或设置器，那么这个访问器或设置器的访问级别也必须是私有的。同样，如果您为一个类的受保护成员定义了访问器或设置器，那么这个访问器或设置器的访问级别也必须是受保护的。</p>
<p>以下是一个 TypeScript 类的例子，其中访问器和设置器具有相同的成员可见性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title function_">value</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的public一般省略</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyClass</code> 类定义了一个私有成员变量 <code>_value</code>，并为它定义了一个访问器 <code>get value()</code> 和一个设置器 <code>set value(newValue: number)</code>。由于 <code>_value</code> 是私有成员，因此访问器和设置器的访问级别也必须是私有的。</p>
<p>访问器和设置器的可见性要求确保了类的封装性和安全性，防止了对类的私有或受保护成员的直接访问。</p>
<h4 id="构造函数（构造器）"><a href="#构造函数（构造器）" class="headerlink" title="构造函数（构造器）"></a>构造函数（构造器）</h4><p>在 TypeScript 中，类的构造函数可以接受参数，并且这些参数可以定义它们的类型。但是，类的构造函数不能有类型参数。</p>
<p>这是因为类型参数是在使用泛型时定义的，它们是在编译时确定的。而构造函数是在运行时调用的，因此在构造函数中定义类型参数是没有意义的。</p>
<p>如果您想在类中使用泛型，可以将泛型类型参数定义为类级别的类型参数，然后在类中的方法和属性中使用它们。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">value</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getValue</span>(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyGenericClass</code> 类接受一个类型参数 <code>T</code>，并在构造函数中接受一个类型为 <code>T</code> 的参数 <code>value</code>。然后，<code>getValue</code> 方法返回类型为 <code>T</code> 的值。</p>
<p>您可以实例化该类并将不同类型的值传递给构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myStringClass = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myStringClass.<span class="title function_">getValue</span>()); <span class="comment">// 输出 &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myNumberClass = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myNumberClass.<span class="title function_">getValue</span>()); <span class="comment">// 输出 42</span></span><br></pre></td></tr></table></figure>

<p>构造函数不能有返回类型注释</p>
<p>在 TypeScript 中，构造函数不能有显式的返回类型注释，因为构造函数的返回值是由类本身确定的，而不是由构造函数的实现决定的。</p>
<p>当您使用 <code>new</code> 操作符实例化一个类时，构造函数会返回该类的实例，而且该实例的类型就是该类本身。因此，您不需要在构造函数中指定返回类型。</p>
<p>以下是一个 TypeScript 类的例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> message: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">myInstance.<span class="title function_">showMessage</span>(); <span class="comment">// 输出 &#x27;Hello, world!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyClass</code> 类的构造函数接受一个 <code>message</code> 参数，并将其保存在类的私有成员变量中。然后，类定义了一个 <code>showMessage</code> 方法，它输出 <code>message</code> 的值。</p>
<p>当我们使用 <code>new</code> 操作符创建一个 <code>MyClass</code> 实例时，不需要指定返回类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>因为构造函数的返回值是 <code>MyClass</code> 类的实例，它的类型已经由类本身决定了。</p>
<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><h4 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h4><ul>
<li>继承接口，需要实现该接口的方法</li>
<li>类也可以实现多个接口，逗号隔开，例如：<code>class c implements A, B &#123;</code></li>
</ul>
<p>注意事项</p>
<p>implements 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 implements 子句会改变类的类型–它不会！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">  <span class="title function_">check</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameChecker</span> <span class="keyword">implements</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">  <span class="title function_">check</span>(<span class="params">s</span>) &#123; <span class="comment">// error 参数&quot;s&quot;隐式具有&quot;any&quot;类型</span></span><br><span class="line">    <span class="comment">// any：注意这里没有错误</span></span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toLowercse</span>() === <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们也许期望 s 的类型会受到 check 的 name: string 参数的影响。事实并非如此–实现子句并没有改变类主体的检查方式或其类型的推断。</p>
<p>同样地，实现一个带有可选属性的接口并不能创建该属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">y</span> = <span class="number">10</span>; <span class="comment">// error 类型&quot;c&quot;上不存在属性&quot;y&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。</p>
<h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">toUpperCase</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">greet</span>();</span><br><span class="line">d.<span class="title function_">greet</span>(<span class="string">&#x27;reader&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过基类引用对派生实例进行取别名</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = d;</span><br><span class="line"><span class="comment">// 没问题</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>如果 Derived 没有遵守Base的约定怎么办？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * error</span></span><br><span class="line"><span class="comment">     * 类型“Derived”中的属性“greet”不可分配给基类型“Base”中的同一属性。</span></span><br><span class="line"><span class="comment">     * 不能将类型“(name: string) =&gt; void”分配给类型“() =&gt; void”。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">toUpperCase</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们不顾错误编译这段代码，这个样本就会崩溃：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="comment">// 崩溃，因为 &quot;name&quot;将是 undefined。</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><p>让我们看看一下这段代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line"> name = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;base&quot;, 而不是 &quot;derived&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure>

<p>这里发生了什么？</p>
<p>按照JavaScript的定义，类初始化的顺序是：</p>
<ul>
<li>基类的字段被初始化</li>
<li>基类构造函数运行</li>
<li>派生类的字段被初始化</li>
<li>派生类构造函数运行</li>
</ul>
<p>这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;base&#x27;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;derived&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My name is base</span><br><span class="line">derived</span><br></pre></td></tr></table></figure>

<h4 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h4><blockquote>
<p>注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置ES6&#x2F;ES2015或以上，你可以跳过本节。</p>
</blockquote>
<p>在ES2015中，返回对象的构造函数隐含地替代了 super(…) 的任何调用者的 this 的值。生成的构造函数代码有必要捕获 super(…) 的任何潜在返回值并将其替换为 this 。因此，子类化 Error 、 Array 等可能不再像预期那样工作。这是由于 Error 、 Array 等的构造函数使用ECMAScript 6的 new.target 来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保 new.target 的值。其他的下级编译器一般默认有同样的限制。</p>
<p>instanceof 将在子类的实例和它们的实例之间被打破，所以 （new MsgError()）instanceofMsgError 将返回 false</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span> + <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msgError = <span class="keyword">new</span> <span class="title class_">MsgError</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msgError <span class="keyword">instanceof</span> <span class="title class_">MsgError</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>你可以在任何 super(…) 调用后立即手动调整原型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">    <span class="comment">// 明确地设置原型。</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="title class_">MsgError</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msgError = <span class="keyword">new</span> <span class="title class_">MsgError</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msgError <span class="keyword">instanceof</span> <span class="title class_">MsgError</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="成员可见性"><a href="#成员可见性" class="headerlink" title="成员可见性"></a>成员可见性</h3><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>所有可访问</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>只对他们所声明的子类可见，子类中可访问，子类实例后不可访问。</p>
<p>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> m = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="comment">// 没有修饰符，所以默认为&#x27;公共&#x27;(&#x27;public&#x27;)</span></span><br><span class="line">  m = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">m</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>派生类不可访问，子类实例后不可访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="comment">// 不能从类外访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不能在子类中访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();</span><br></pre></td></tr></table></figure>

<p>静态成员也可以使用相同的 public 、 protected 和 private 可见性修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br></pre></td></tr></table></figure>

<p>静态成员也会被继承。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getGreeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line"> myGreeting = <span class="title class_">Derived</span>.<span class="title function_">getGreeting</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊静态名称"><a href="#特殊静态名称" class="headerlink" title="特殊静态名称"></a>特殊静态名称</h4><p>一般来说，从函数原型覆盖属性是不安全的&#x2F;不可能的。因为类本身就是可以用 new 调用的函数，所以某些静态名称不能使用。像 name 、 length 和 call 这样的函数属性，定义为静态成员是无效的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&#x27;s!&#x27;</span>; <span class="comment">// error 静态属性“name”与构造函数“S”的内置属性函数“name”冲突。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么没有静态类"><a href="#为什么没有静态类" class="headerlink" title="为什么没有静态类"></a>为什么没有静态类</h4><p>TypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。</p>
<p>这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript&#x2F;TypeScript中通常只是表示为一个普通的对象。</p>
<p>例如，我们不需要TypeScript中的 “静态类 “语法，因为一个普通的对象（甚至是顶级函数）也可以完成</p>
<p>这个工作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 &quot;static&quot; class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStaticClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首选 (备选 1)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 首选 (备选 2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyHelperObject</span> = &#123;</span><br><span class="line">    <span class="title function_">dosomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类里的-static区块"><a href="#类里的-static区块" class="headerlink" title="类里的 static区块"></a>类里的 static区块</h4><p>静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> #count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">count</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Foo</span>.#count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lastInstances = &#123;</span><br><span class="line">                <span class="attr">length</span>: <span class="number">100</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title class_">Foo</span>.#count += lastInstances.<span class="property">length</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类运行时中的this"><a href="#类运行时中的this" class="headerlink" title="类运行时中的this"></a>类运行时中的this</h3><p>TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: c.<span class="property">getName</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出 &quot;obj&quot;, 而不是 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>

<p>长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>如果你有一个经常会被调用的函数，失去了它的 this 上下文，那么使用一个箭头函数而不是方法定义是有意义的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="comment">// 输出 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure>

<p>这有一些权衡：</p>
<ul>
<li>this 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。</li>
<li>这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。</li>
<li>你不能在派生类中使用 super.getName ，因为在原型链中没有入口可以获取基类方法。</li>
</ul>
<h4 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h4><p>在方法或函数定义中，一个名为 this 的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程</p>
<p>中会被删除。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有 &quot;this&quot; 参数的 TypeScript 输入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: SomeType, x: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后的JavaScript结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript检查调用带有 this 参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个 this 参数，以静态地确保方法被正确调用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: MyClass</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.<span class="title function_">getName</span>();</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure>

<p>这种方法做出了与箭头函数方法相反的取舍：</p>
<ul>
<li><p>JavaScript调用者仍然可能在不知不觉中错误地使用类方法</p>
</li>
<li><p>每个类定义只有一个函数被分配，而不是每个类实例一个函数</p>
</li>
<li><p>基类方法定义仍然可以通过 super 调用。</p>
</li>
</ul>
<h3 id="this类型"><a href="#this类型" class="headerlink" title="this类型"></a>this类型</h3><p>在类中，一个叫做 this 的特殊类型动态地指向当前类的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = value;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Box&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClearableBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">ClearableBox</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">set</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box ClearableBox &#123; content: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">ClearableBox &#123; content: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Box类set方法的this指向了ClearableBox类。</p>
<p>参数类型注释中使用this，如果你有一个派生类，它的sameAs方法现在只接受该同一派生类的其他实例了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">sameAs</span>(<span class="params">other: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> other.<span class="property">content</span> === <span class="variable language_">this</span>.<span class="property">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">    <span class="attr">otherContent</span>: <span class="built_in">string</span> = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> <span class="title class_">DerivedBox</span>();</span><br><span class="line"><span class="keyword">const</span> derivedc = <span class="keyword">new</span> <span class="title class_">DerivedBox</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(derived.<span class="title function_">sameAs</span>(derivedc));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * error </span></span><br><span class="line"><span class="comment"> * 类型“Box”的参数不能赋给类型“DerivedBox”的参数。</span></span><br><span class="line"><span class="comment"> * 类型 &quot;Box&quot; 中缺少属性 &quot;otherContent&quot;，但类型 &quot;DerivedBox&quot; 中需要该属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(derived.<span class="title function_">sameAs</span>(base));</span><br></pre></td></tr></table></figure>

<h3 id="基于类型守卫的this"><a href="#基于类型守卫的this" class="headerlink" title="基于类型守卫的this"></a>基于类型守卫的this</h3><p>常用的一个地方是允许对一个特定字段进行惰性验证。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  value?: T;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">hasValue</span>(): <span class="variable language_">this</span> is &#123; <span class="attr">value</span>: T &#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.<span class="property">value</span> = <span class="string">&#x27;Gameboy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (property) Box&lt;unknown&gt;.value?: unknownbox.value;</span></span><br><span class="line"><span class="keyword">if</span> (box.<span class="title function_">hasValue</span>()) &#123;</span><br><span class="line">  <span class="comment">// (property) value: unk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在构造函数中加入参数属性，可以简写了，不用在外面定义属性了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>, <span class="keyword">protected</span> y: <span class="built_in">number</span>, <span class="keyword">private</span> z: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * error</span></span><br><span class="line"><span class="comment"> * 无法重新声明块范围变量“p”。</span></span><br><span class="line"><span class="comment"> * 属性“y”受保护，只能在类“Params”及其子类中访问。</span></span><br><span class="line"><span class="comment"> * 属性“z”为私有属性，只能在类“Params”中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Params</span>(<span class="number">100</span>, <span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">x</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类表达式写法"><a href="#类表达式写法" class="headerlink" title="类表达式写法"></a>类表达式写法</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someClass = <span class="keyword">class</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title function_">someClass</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">content</span>);</span><br></pre></td></tr></table></figure>

<h3 id="抽象类和成员"><a href="#抽象类和成员" class="headerlink" title="抽象类和成员"></a>抽象类和成员</h3><p>抽象类不能被实例化，即不能用new，需要常见派生类来实现抽象成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="keyword">abstract</span> <span class="title function_">getName</span>(): <span class="built_in">string</span>;</span><br><span class="line"> <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">printName</span>();</span><br></pre></td></tr></table></figure>

<h4 id="抽象构造签名"><a href="#抽象构造签名" class="headerlink" title="抽象构造签名"></a>抽象构造签名</h4><p>有时候你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。</p>
<p>可能想这样写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">typeof</span> Base</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>(); <span class="comment">// 无法创建抽象类的实例。</span></span><br><span class="line">  instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Typescript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于green的定义，写的这段代码是完全合法的，他最终会构造一个抽象类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>)</span><br></pre></td></tr></table></figure>

<p>相反，你想写一个函数，接受具有结构化签名的东西：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">new</span> () =&gt; Base</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">    instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Derived</span>);</span><br><span class="line"><span class="comment">// greet(Base);</span></span><br></pre></td></tr></table></figure>

<p>现在TypeScript正确地告诉你哪些类的构造函数可以被调用： Derived 可以，因为它是具体的，但Base 不能。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类型“typeof Base”的参数不能赋给类型“new () =&gt; Base”的参数。</span></span><br><span class="line"><span class="comment"># 无法将抽象构造函数类型分配给非抽象构造函数类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>相同的两个类之间可以相互代替使用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point1</span> &#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> &#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point1</span> = <span class="keyword">new</span> <span class="title class_">Point2</span>();</span><br></pre></td></tr></table></figure>

<p>包含关系的两个类之间也可以使用，小的类作为类型。这句话的理解：即使没有明确的继承，类之间的子类型关系也是存在的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point1</span> &#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> &#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point1</span> = <span class="keyword">new</span> <span class="title class_">Point2</span>();</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point2</span> = <span class="keyword">new</span> <span class="title class_">Point1</span>();</span><br></pre></td></tr></table></figure>

<p>下面这种情况会特殊点，空的类没有成员，在一个结构化类型系统中，一个没有成员的类型通常是其他任何类型的超类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// 不能用x做任何事</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下均可调用</span></span><br><span class="line">!<span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="认识模块"><a href="#认识模块" class="headerlink" title="认识模块"></a>认识模块</h3><p>主要考虑三个：</p>
<ul>
<li>语法：我想用什么语法来导入和导出？</li>
<li>模块解析：模块名称（或路径）和磁盘上的文件之间是什么关系？</li>
<li>模块输出目标：我编译出来的js模块应该是什么样子的？</li>
</ul>
<h3 id="额外的导入语法"><a href="#额外的导入语法" class="headerlink" title="额外的导入语法"></a>额外的导入语法</h3><p>示例的目录结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">|   --- export.ts</span><br><span class="line">|   --- index.ts</span><br></pre></td></tr></table></figure>

<p>export.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>index.ts 引入 export.ts</p>
<p>写法一</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">RNGen</span>, &#123; pi <span class="keyword">as</span> π &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(π);</span><br><span class="line"><span class="keyword">const</span> rnGen = <span class="keyword">new</span> <span class="title class_">RNGen</span>();</span><br></pre></td></tr></table></figure>

<p>写法二</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="property">pi</span>);</span><br><span class="line"><span class="keyword">const</span> rnGen = <span class="keyword">new</span> math.<span class="title function_">default</span>();</span><br></pre></td></tr></table></figure>

<h3 id="TS特定的ES模块语法"><a href="#TS特定的ES模块语法" class="headerlink" title="TS特定的ES模块语法"></a>TS特定的ES模块语法</h3><p>如果是扩展类型和常规结合使用，写法如下：</p>
<p>示例的目录结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">|   --- export.ts</span><br><span class="line">|   --- index.ts</span><br></pre></td></tr></table></figure>

<p>export.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Cat</span> = &#123;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">yearOfBirth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">yearOfBirth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createCatName</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>index.ts</p>
<p>如果只引入扩展类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果引入扩展类型和非扩展类型的其他东西，如函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createCatName, <span class="keyword">type</span> <span class="title class_">Cat</span>, <span class="keyword">type</span> <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，引入<code>export.ts</code>时，是不带<code>.ts</code>的，因为编译后的是js，而非ts文件。</p>
<h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript 中的一些独特概念在类型级别描述了 JavaScript 对象的形状。TypeScript 特别独特的一个例子是“声明合并”的概念。理解这个概念将使您在使用现有 JavaScript 时更有优势。它还为更高级的抽象概念打开了大门。</p>
<p>就本文而言，“声明合并”是指编译器将两个单独的同名声明合并为一个定义。这个合并的定义具有两个原始声明的特征。可以合并任意数量的声明；它不仅限于两个声明。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在 TypeScript 中，声明至少在三组中的一组中创建实体：命名空间、类型或值。创建命名空间的声明创建了一个命名空间，其中包含使用点分符号访问的名称。类型创建声明就是这样做的：它们创建一个类型，该类型对声明的形状可见并绑定到给定的名称。最后，创建值的声明创建在输出 JavaScript 中可见的值。</p>
<table>
<thead>
<tr>
<th align="left">Declaration Type</th>
<th align="left">Namespace</th>
<th align="left">Type</th>
<th align="left">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Namespace</td>
<td align="left">X</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Class</td>
<td align="left"></td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Enum</td>
<td align="left"></td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Interface</td>
<td align="left"></td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Type Alias</td>
<td align="left"></td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Variable</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">X</td>
</tr>
</tbody></table>
<p>了解每个声明创建的内容将帮助您了解执行声明合并时合并的内容。</p>
<h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><p>最简单，也许是最常见的声明合并类型是接口合并。在最基本的层面上，合并将两个声明的成员机械地连接到一个同名的接口中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">scale</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">box</span>: <span class="title class_">Box</span> = &#123; <span class="attr">height</span>: <span class="number">5</span>, <span class="attr">width</span>: <span class="number">6</span>, <span class="attr">scale</span>: <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>接口的非函数成员应该是唯一的。如果它们不是唯一的，则它们必须属于同一类型。如果接口都声明了同名但类型不同的非函数成员，编译器将发出错误。</p>
<p>对于函数成员，每个同名的函数成员都被视为描述同一函数的重载。同样值得注意的是，在接口<code>A</code>与后来的接口<code>A</code>合并的情况下，<strong>第二个接口将比第一个接口具有更高的优先级</strong>。</p>
<p>也就是说，在示例中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个接口将合并以创建一个声明，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，每个组的元素都保持相同的顺序，但组本身是合并的，后来的重载组先排序。</p>
<p>此规则的一个例外是专用签名。如果签名的参数类型是<em>单个</em>字符串文字类型（例如，不是字符串文字的并集），那么它将冒泡到其合并的重载列表的顶部。</p>
<blockquote>
<p>并集也称联合</p>
</blockquote>
<p>例如，以下接口将合并在一起：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的合并声明<code>Document</code>如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并命名空间"><a href="#合并命名空间" class="headerlink" title="合并命名空间"></a>合并命名空间</h3><p>与接口类似，同名的命名空间也会合并它们的成员。由于命名空间同时创建命名空间和值，我们需要了解两者如何合并。</p>
<p>为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身被合并，形成一个内部具有合并接口定义的命名空间。</p>
<p>要合并名称空间值，在每个声明站点，如果已存在具有给定名称的名称空间，则通过采用现有名称空间并<strong>将第二个名称空间的导出成员添加到第一个名称空间</strong>来进一步扩展它。</p>
<p>本例中的声明合并<code>Animals</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Zebra</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Zebra</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种名称空间合并模型是一个有用的起点，但我们还需要了解非导出成员会发生什么。非导出成员仅在原始（未合并的）命名空间中可见。这意味着合并后，来自其他声明的合并成员看不到非导出成员。</p>
<p>我们可以在这个例子中更清楚地看到这一点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> haveMuscles = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">animalsHaveMuscles</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doAnimalsHaveMuscles</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles; <span class="comment">// Error, because haveMuscles is not accessible here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>haveMuscles</code>未导出，所以只有<code>animalsHaveMuscles</code>共享相同未合并命名空间的函数才能看到该符号。该<code>doAnimalsHaveMuscles</code>函数，即使它是合并<code>Animal</code>命名空间的一部分，也看不到这个未导出的成员。</p>
<h3 id="将命名空间与类、函数和枚举合并"><a href="#将命名空间与类、函数和枚举合并" class="headerlink" title="将命名空间与类、函数和枚举合并"></a>将命名空间与类、函数和枚举合并</h3><p>命名空间足够灵活，可以与其他类型的声明合并。为此，名称空间声明必须跟在它将合并的声明之后。生成的声明具有两种声明类型的属性。TypeScript 使用此功能对 JavaScript 和其他编程语言中的某些模式进行建模。</p>
<h3 id="将命名空间与类合并"><a href="#将命名空间与类合并" class="headerlink" title="将命名空间与类合并"></a>将命名空间与类合并</h3><p>这为用户提供了一种描述内部类的方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Album</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="title class_">Album</span>.<span class="property">AlbumLabel</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Album</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AlbumLabel</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces">合并成员的可见性规则与合并命名空间</a>部分中描述的相同，因此我们必须导出类<code>AlbumLabel</code>以供合并类查看。最终结果是在另一个类内部管理一个类。您还可以使用名称空间向现有类添加更多静态成员。</p>
<p>除了内部类模式之外，您可能还熟悉创建函数然后通过向函数添加属性来进一步扩展函数的 JavaScript 实践。TypeScript 使用声明合并以类型安全的方式构建这样的定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> buildLabel.<span class="property">prefix</span> + name + buildLabel.<span class="property">suffix</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> buildLabel &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> suffix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> prefix = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildLabel</span>(<span class="string">&quot;Sam Smith&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>同样，命名空间可用于扩展具有静态成员的枚举：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  red = <span class="number">1</span>,</span><br><span class="line">  green = <span class="number">2</span>,</span><br><span class="line">  blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mixColor</span>(<span class="params">colorName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (colorName == <span class="string">&quot;yellow&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Color</span>.<span class="property">red</span> + <span class="title class_">Color</span>.<span class="property">green</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Color</span>.<span class="property">red</span> + <span class="title class_">Color</span>.<span class="property">green</span> + <span class="title class_">Color</span>.<span class="property">blue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;magenta&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Color</span>.<span class="property">red</span> + <span class="title class_">Color</span>.<span class="property">blue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;cyan&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Color</span>.<span class="property">green</span> + <span class="title class_">Color</span>.<span class="property">blue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不允许合并"><a href="#不允许合并" class="headerlink" title="不允许合并"></a>不允许合并</h3><p>并非所有合并都在 TypeScript 中被允许。目前，类不能与其他类或变量合并。有关模拟类合并的信息，请参阅<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/mixins.html">TypeScript 中的混合</a>部分。</p>
<h3 id="模组扩充"><a href="#模组扩充" class="headerlink" title="模组扩充"></a>模组扩充</h3><p>尽管 JavaScript 模块不支持合并，但您可以通过导入然后更新现有对象来修补它们。让我们看一个玩具 Observable 示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observable.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ... implementation left as an exercise for the reader ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="title class_">Observable</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这在 TypeScript 中也能正常工作，但编译器不知道<code>Observable.prototype.map</code>. 您可以使用模块扩充将其告知编译器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observable.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ... implementation left as an exercise for the reader ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;./observable&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Observable</span>&lt;T&gt; &#123;</span><br><span class="line">    map&lt;U&gt;(<span class="attr">f</span>: <span class="function">(<span class="params">x: T</span>) =&gt;</span> U): <span class="title class_">Observable</span>&lt;U&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Observable</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./map&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">o</span>: <span class="title class_">Observable</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">o.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">toFixed</span>());</span><br></pre></td></tr></table></figure>

<p><code>import</code>模块名称的解析方式与&#x2F;中的模块说明符相同<code>export</code>。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/modules.html">模块。</a>然后合并扩充中的声明，就好像它们是在与原始文件相同的文件中声明的一样。</p>
<p>但是，请记住两个限制：</p>
<ol>
<li>您不能在扩充中声明新的顶级声明——只是对现有声明的补丁。</li>
<li>默认导出也不能被扩充，只能被命名为导出（因为您需要通过其导出名称来扩充导出，并且<code>default</code>是一个保留字 - 有关详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/14080">#14080</a>）</li>
</ol>
<h3 id="全局增强"><a href="#全局增强" class="headerlink" title="全局增强"></a>全局增强</h3><p>您还可以从模块内部向全局范围添加声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observable.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ... still no implementation ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">toObservable</span>(): <span class="title class_">Observable</span>&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toObservable</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>全局扩充与模块扩充具有相同的行为和限制。</p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><h3 id="创建一个对象会做哪三件事"><a href="#创建一个对象会做哪三件事" class="headerlink" title="创建一个对象会做哪三件事"></a>创建一个对象会做哪三件事</h3><h3 id="js垃圾回收机制触发时机"><a href="#js垃圾回收机制触发时机" class="headerlink" title="js垃圾回收机制触发时机"></a>js垃圾回收机制触发时机</h3><h3 id="ts编译为es5，class编译成了立即执行函数？"><a href="#ts编译为es5，class编译成了立即执行函数？" class="headerlink" title="ts编译为es5，class编译成了立即执行函数？"></a>ts编译为es5，class编译成了立即执行函数？</h3><p>避免变量名别污染</p>
<h3 id="静态方法中只能调用静态的方法或属性？"><a href="#静态方法中只能调用静态的方法或属性？" class="headerlink" title="静态方法中只能调用静态的方法或属性？"></a>静态方法中只能调用静态的方法或属性？</h3><p>是的，跟非静态方法或属性是独立的，反之也是。</p>
<h3 id="一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变？"><a href="#一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变？" class="headerlink" title="一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变？"></a>一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变？</h3><p>是。这个非静态方法，new object有区别。</p>
<h3 id="静态属性或方法分配内存空间的时间早于对象空间的分配？"><a href="#静态属性或方法分配内存空间的时间早于对象空间的分配？" class="headerlink" title="静态属性或方法分配内存空间的时间早于对象空间的分配？"></a>静态属性或方法分配内存空间的时间早于对象空间的分配？</h3><p>是。静态属性或方法分配内存空间会一直在，直到程序执行结束才被释放。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="醉梦 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>醉梦
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.huatree.top/2021/11/12/20211112-typescript%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/" title="typescript成长之路">https://www.huatree.top/2021/11/12/20211112-typescript成长之路/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/typescript/" rel="tag"># typescript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/27/20210927-%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/" rel="prev" title="前端文件上传下载">
                  <i class="fa fa-chevron-left"></i> 前端文件上传下载
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/26/20211126-Vue%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8C%87%E5%8D%97/" rel="next" title="Vue开发工具指南">
                  Vue开发工具指南 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2022016364号-1 </a>
  </div>

<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">醉梦</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">359k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:26</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"huatree","repo":"huatree.gitalk.io","client_id":"f058094b28cadc38c8bf","client_secret":"b5259994ff1994db4b3b6124a3fe83fe2e0e9711","admin_user":"huatree","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","id":"location.pathname","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"1f9b21696d91e230ab535c3349780bb5"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
